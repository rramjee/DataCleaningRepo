x[(n-1):n,]
n<-nrow(x)
max(subset(x, x$Month==5)[,1],na.rm=T)
mean(subset(x, x$Month==6)[,4],na.rm=T)
subset(x, x$Month==6)
mean(u[,2],na.rm=T)
subset(x, x$Ozone>31|x$Temp>90)
sd(e[1,])
sd(k[1,])

>require(stats)
> tapply(iris$Sepal.Length, iris$Species,mean)
 or 
apply(subset(iris,iris$Species=='virginica')[, 1:4], 2, mean)

apply(iris[, 1:4], 2, mean)

sapply(split(iris$Sepal.Length, iris$Species), mean)

sapply(split(mtcars, mtcars$cyl), function(x) colMeans(x[,c("disp","hp")]) )

tapply(mtcars$hp, mtcars$cyl,mean )

subset(mtcars,mtcars$hp==4)[,]

abs(tapply(mtcars$hp,mtcars$cyl==4,mean)[2] - tapply(mtcars$hp,mtcars$cyl==8,mean)[2])

 




makeCacheMatrix<- function(x = matrix()) {
        m <- NULL
        set <- function(y) {
                x <<- y
                m <<- NULL
        }
        get <- function() x
        setmatrix <- function(matrix) m <<- matrix
        getmatrix <- function() m
        list(set = set, get = get,
             setmatrix = setmatrix,
             getmatrix = getmatrix)
}

cacheSolve <- function(x, ...) {
        m <- x$getmatrix()
        if(!is.null(m)) {
                message("getting cached data")
                return(m)
        }
        data <- x$get()
        m <- solve(data, ...)
        x$setmatrix(m)
        m
}



as.character(cls_list) to convert list to character vector

getwd()

ls() - list of objects in the work space
dir()
args(list.files) - to get list of arguements of a function
dir.create("testdir") - to create a test directory under working directory

setwd("testdir") - to set test dir as working dir

file.create("mytest.R") - to create a file in the working directory
 file.exists("mytest.R")
file.info("mytest.R") to get details of the file.
file.info("mytest.R")$mode --- to grab specific items.

file.create(..., showWarnings = TRUE)

unlink("testdir2",recursive=TRUE) - to delete a directory and all it contents

 pi:10
[1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593

my_seq <- 1:30
seq_along(my_seq) or seq(along.with = my_seq) to generate sequence from 1 to my_seq
file.exists(...)

rep(c(0,1,2),times = 10)

my_char<-c("My","name","is")
paste(my_char,collapse = " ")
paste("Hello", "world!", sep = " ")

> paste(1:3,c("X","Y","Z"),sep = "")
[1] "1X" "2Y" "3Z"

 x[is.na(x)] - to get all non- NA values of vectory x

x[c(-2,-10)] - to get all values except 2nd and 10th
x[-c(2,10)] same as above


assigning col names to dta frame
cnames<-c("patient","age","weight","bp","rating","test")
colnames(my_data)<-cnames

 Dates are represented by the 'Date' class and times are represented by the 'POSIXct' and 'POSIXlt' classes. Internally, dates are stored as the number of days
| since 1970-01-01 and times are stored as either the number of seconds since 1970-01-01 (for 'POSIXct') or a list of seconds, minutes, hours, etc. (for 'POSIXlt').

d2<-as.Date("1969-01-01")

by default Sys.time() will give in posixct

t2<-as.POSIXlt(Sys.time())

t3<- "October 17, 1986 08:24"
 t4<-strptime(t3, "%B %d, %Y %H:%M") 

 difftime(Sys.time(),t1,units='days')

Time difference of 0.009432067 days

posixlt stores in a list format. you can access year, mon and every parameter like a list
t2$min

| strptime() converts character vectors to POSIXlt. In that sense, it is similar to as.POSIXlt(), except that the input doesn't have to be in a
| particular format (YYYY-MM-DD)
.



file.remove(...)
file.rename(from, to)
file.append(file1, file2)
file.copy(from, to, overwrite = recursive, recursive = FALSE,
          copy.mode = TRUE, copy.date = FALSE)
file.symlink(from, to)
file.link(from, to)
Sys.junction(from, to)

> ints<-sample(10)
> ints
 [1]  5  8  6  9  4  2 10  1  7  3

> which(ints>7)
[1] 2 4 7

> any(ints<0)
[1] FALSE

 all(ints>0)
[1] TRUE



to check if a particular column exists in a data frame - 
grepl("Number.of.Patients...Hospital.30.Day.Readmission.Rates.from.Heart.Attack", names(outcome))

you can also use 
grepl("^d$",names(dat))


--Downloading data from web
if (!file.exists("data")) {
    dir.create("data")
}
fileUrl <- "https://data.baltimorecity.gov/api/views/dz54-2aru/rows.csv?accessType=DOWNLOAD"
download.file(fileUrl, destfile = "./data/cameras.csv", method = "curl") 
or dest<-download.file(fileurl, destfile = "./data/survey.csv", method = "libcurl")
list.files("./data")

inputData<-read.csv("./data/assignment.csv",quote="")
-- quote="" - to take care of problem with single and double quotes

----------------------------------------------------------------------------------------
Error in .jcall("RJavaTools", "Ljava/lang/Object;", "invokeMethod", cl,  : 
  java.util.zip.ZipException: invalid code -- missing end-of-block 
http://stackoverflow.com/questions/28325744/r-xlsx-package-error

download.file(fileUrl2, destfile = "./data/assignmentque2.xlsx",mode="wb")


to read subset of rows and columns from excel - 
 read.xlsx("./data/assignmentque2.xlsx",sheetIndex=1,colIndex=7:15,rowIndex=18:23)


XML

library(XML)
fileUrl <- "http://www.w3schools.com/xml/simple.xml"
doc <- xmlTreeParse(fileUrl,useInternal=TRUE)
rootNode <- xmlRoot(doc)
xmlName(rootNode)
names(rootNode)
rootNode[[1]]
rootNode[[1]][[1]]

xmlSApply(rootNode,xmlValue)

/node Top level node
//node Node at any level
node[@attr-name] Node with an attribute name
node[@attr-name='bob'] Node with attribute name attr-name='bob'

Xpath
xpathSApply(rootNode,"//price",xmlValue)
scores <- xpathSApply(doc,"//li[@class='score']",xmlValue)
teams <- xpathSApply(doc,"//li[@class='team-name']",xmlValue)

to get count of node having a particular value
length(xpathSApply(xmltop,path="(//row/zipcode[text()='21231'])",xmlValue))

group by on data tables (using :=)

DT[,b:= mean(x+w),by=a]

DT[,a:=x>0]

DT <- data.table(x=sample(letters[1:3], 1E5, TRUE))
> DT[, .N, by=x] (this means group by values of x and sort by values in N)
 (to be verified if the understanding of .N is correct)

sqldf("select unique AGEP from acs") ## query from data frame using sql df package